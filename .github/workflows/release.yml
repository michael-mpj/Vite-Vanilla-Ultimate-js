name: üè∑Ô∏è Release Management

on:
  push:
    branches: [main]
    paths-ignore:
      - 'docs/**'
      - 'docs-site/**'
      - '*.md'
      - '.gitignore'
      - '.github/**'
  workflow_dispatch:
    inputs:
      release-type:
        description: 'Release type'
        required: true
        default: 'auto'
        type: choice
        options:
          - auto
          - patch
          - minor
          - major
          - prerelease

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  # üìã Analyze commits for release
  analyze-commits:
    name: üìã Analyze Commits
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: >-
      !contains(github.event.head_commit.message, 'chore: auto-maintenance') &&
      !contains(github.event.head_commit.message, '[skip release]')

    outputs:
      should-release: ${{ steps.analysis.outputs.should-release }}
      release-type: ${{ steps.analysis.outputs.release-type }}
      changes-summary: ${{ steps.analysis.outputs.changes-summary }}

    steps:
      - name: üì¶ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üìã Analyze commits for release
        id: analysis
        run: |
          # Get the last tag or use initial commit if no tags exist
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || git rev-list --max-parents=0 HEAD)
          echo "Last tag: $LAST_TAG"

          # Get commits since last tag
          COMMITS=$(git log ${LAST_TAG}..HEAD --oneline)
          echo "Commits since last tag:"
          echo "$COMMITS"

          # Initialize variables
          SHOULD_RELEASE=false
          RELEASE_TYPE="patch"
          FEAT_COUNT=0
          FIX_COUNT=0
          BREAKING_COUNT=0
          OTHER_COUNT=0

          # Analyze commits
          while IFS= read -r commit; do
            if [[ $commit =~ ^[a-f0-9]+[[:space:]]+(feat|feature)(\(.+\))?(!)?:.* ]]; then
              FEAT_COUNT=$((FEAT_COUNT + 1))
              SHOULD_RELEASE=true
              if [[ $commit =~ ! ]]; then
                BREAKING_COUNT=$((BREAKING_COUNT + 1))
              fi
            elif [[ $commit =~ ^[a-f0-9]+[[:space:]]+(fix|bugfix)(\(.+\))?:.* ]]; then
              FIX_COUNT=$((FIX_COUNT + 1))
              SHOULD_RELEASE=true
            elif [[ $commit =~ BREAKING[[:space:]]CHANGE ]]; then
              BREAKING_COUNT=$((BREAKING_COUNT + 1))
              SHOULD_RELEASE=true
            elif [[ $commit =~ ^[a-f0-9]+[[:space:]]+(perf|docs|style|refactor|test|chore)(\(.+\))?:.* ]]; then
              OTHER_COUNT=$((OTHER_COUNT + 1))
              # These don't trigger releases by default unless manually specified
            fi
          done <<< "$COMMITS"

          # Determine release type
          if [[ $BREAKING_COUNT -gt 0 ]]; then
            RELEASE_TYPE="major"
          elif [[ $FEAT_COUNT -gt 0 ]]; then
            RELEASE_TYPE="minor"
          elif [[ $FIX_COUNT -gt 0 ]]; then
            RELEASE_TYPE="patch"
          fi

          # Override with manual input if provided
          if [[ "${{ github.event.inputs.release-type }}" != "" && "${{ github.event.inputs.release-type }}" != "auto" ]]; then
            RELEASE_TYPE="${{ github.event.inputs.release-type }}"
            SHOULD_RELEASE=true
          fi

          # Create changes summary
          CHANGES_SUMMARY="üîç **Release Analysis:**
          - üÜï Features: $FEAT_COUNT
          - üêõ Bug fixes: $FIX_COUNT
          - üí• Breaking changes: $BREAKING_COUNT
          - üìù Other changes: $OTHER_COUNT
          - üì¶ Release type: $RELEASE_TYPE"

          echo "should-release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT
          echo "release-type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
          echo "changes-summary<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGES_SUMMARY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "Analysis complete:"
          echo "Should release: $SHOULD_RELEASE"
          echo "Release type: $RELEASE_TYPE"

  # üß™ Pre-release testing
  pre-release-test:
    name: üß™ Pre-release Testing
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: analyze-commits
    if: needs.analyze-commits.outputs.should-release == 'true'

    steps:
      - name: üì¶ Checkout repository
        uses: actions/checkout@v4

      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22.0.0'
          cache: 'npm'

      - name: üì• Install dependencies
        run: npm ci

      - name: üîç Run quality checks
        run: npm run check

      - name: üèóÔ∏è Test build
        run: npm run build

      - name: üìñ Test docs build
        run: npm run docs:build

  # üè∑Ô∏è Create release
  create-release:
    name: üè∑Ô∏è Create Release
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [analyze-commits, pre-release-test]
    if: needs.analyze-commits.outputs.should-release == 'true'

    outputs:
      new-version: ${{ steps.release.outputs.new-version }}
      release-url: ${{ steps.release.outputs.release-url }}

    steps:
      - name: üì¶ Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22.0.0'
          cache: 'npm'

      - name: üì• Install dependencies
        run: npm ci

      - name: üèóÔ∏è Build for release
        run: npm run build

      - name: üîß Configure Git
        run: |
          git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

      - name: üè∑Ô∏è Create release
        id: release
        run: |
          RELEASE_TYPE="${{ needs.analyze-commits.outputs.release-type }}"
          echo "Creating $RELEASE_TYPE release..."

          # Run standard-version
          if [[ "$RELEASE_TYPE" == "prerelease" ]]; then
            npm run release -- --prerelease
          else
            npm run release:$RELEASE_TYPE
          fi

          # Get the new version
          NEW_VERSION=$(node -p "require('./package.json').version")
          echo "new-version=v$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: v$NEW_VERSION"

          # Push the changes and tags
          git push --follow-tags origin main

          # Create GitHub release
          LATEST_TAG=$(git describe --tags --abbrev=0)
          CHANGELOG_CONTENT=$(git log --oneline $(git describe --tags --abbrev=0 HEAD~1)..HEAD --pretty=format:"- %s (%h)" || echo "- Initial release")

          gh release create "$LATEST_TAG" \
            --title "Release $LATEST_TAG" \
            --notes "## What's Changed

          ${{ needs.analyze-commits.outputs.changes-summary }}

          ## Commits
          $CHANGELOG_CONTENT

          **Full Changelog**: https://github.com/${{ github.repository }}/compare/$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || 'HEAD')...$LATEST_TAG" \
            --verify-tag
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: üìù Update documentation
        run: |
          # Update any version references in docs if needed
          if [[ -f "docs-site/index.md" ]]; then
            NEW_VERSION="${{ steps.release.outputs.new-version }}"
            sed -i.bak "s/version: .*/version: $NEW_VERSION/" docs-site/index.md || true
            rm -f docs-site/index.md.bak

            if [[ -n "$(git status --porcelain)" ]]; then
              git add docs-site/index.md
              git commit -m "docs: update version in documentation to $NEW_VERSION"
              git push
            fi
          fi

  # üì¢ Post-release notifications
  post-release:
    name: üì¢ Post-release Actions
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [analyze-commits, create-release]
    if: needs.create-release.result == 'success'

    steps:
      - name: üì¶ Checkout repository
        uses: actions/checkout@v4

      - name: üì¢ Create release summary
        run: |
          echo "## üéâ Release Complete!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.create-release.outputs.new-version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Type:** ${{ needs.analyze-commits.outputs.release-type }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "${{ needs.analyze-commits.outputs.changes-summary }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üîó [View Release](https://github.com/${{ github.repository }}/releases/tag/${{ needs.create-release.outputs.new-version }})" >> $GITHUB_STEP_SUMMARY

      - name: üìù Comment on related PRs
        uses: actions/github-script@v7
        with:
          script: |
            const version = "${{ needs.create-release.outputs.new-version }}";
            const releaseType = "${{ needs.analyze-commits.outputs.release-type }}";

            // Find recently merged PRs
            const { data: pulls } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              sort: 'updated',
              direction: 'desc',
              per_page: 10
            });

            const recentMergedPRs = pulls.filter(pr =>
              pr.merged_at &&
              new Date(pr.merged_at) > new Date(Date.now() - 24 * 60 * 60 * 1000) // Last 24 hours
            );

            for (const pr of recentMergedPRs) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: `üéâ This PR has been included in release [${version}](https://github.com/${context.repo.owner}/${context.repo.repo}/releases/tag/${version})!`
              });
            }

  # ‚úÖ Release complete
  release-complete:
    name: ‚úÖ Release Pipeline Complete
    runs-on: ubuntu-latest
    needs: [analyze-commits, pre-release-test, create-release, post-release]
    if: always()

    steps:
      - name: üìä Check release status
        run: |
          echo "üìã Analysis: ${{ needs.analyze-commits.result }}"
          echo "üß™ Pre-release Test: ${{ needs.pre-release-test.result }}"
          echo "üè∑Ô∏è Create Release: ${{ needs.create-release.result }}"
          echo "üì¢ Post Release: ${{ needs.post-release.result }}"

          if [[ "${{ needs.analyze-commits.outputs.should-release }}" == "false" ]]; then
            echo "‚ÑπÔ∏è No release needed - no significant changes detected"
          elif [[ "${{ needs.create-release.result }}" == "success" ]]; then
            echo "‚úÖ Release pipeline completed successfully"
            echo "üéâ New version: ${{ needs.create-release.outputs.new-version }}"
          else
            echo "‚ùå Release pipeline failed"
            exit 1
          fi
